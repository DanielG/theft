# Properties

Property tests say something deeper about the code under test than
example-based tests, and coming up with useful properties to test
can be a bit daunting. Fortunately, there is a lot of good writing
about effectively applying property-based testing.

There are several good articles about good properties to test based on
examples in other languages (such as Haskell, Python, F#, ...), and the
concepts usually port of well even if the test library APIs are
significantly different.

[what-is-pbt]: http://hypothesis.works/articles/what-is-property-based-testing/

[getting-started]: http://www.drmaciver.com/2016/03/the-easy-way-to-get-started-with-property-based-testing/

[choosing-properties]: https://fsharpforfunandprofit.com/posts/property-based-testing-2/


## Example Properties

### During performance tuning

+ For any input, the version of some code that adds clever optimizations
  should always produce the same result as a straightforward version
  that is too inefficient for production use, but is much easier to
  check.

### In a data compression library:

+ For any input, compressing and uncompressing it should produce output
  that matches the original input.

+ For any input, the compression output should never be larger than the
  original input, beyond some small algorithm-specific overhead.

+ For any input, the uncompression state machine should never get stuck;
  it should always be able to reach a valid end-of-stream state once
  the end of input is reached.

### In a storage library:

+ For any sequence of operations, any records that the library says have
  been safely written should be readable later.

+ Interleaving those operations with resetting the library's state
  in-memory and re-reading headers to recover the current storage
  state should never cause data loss.

+ Injecting temporary hardware faults should lead to errors being
  handled correctly and recovering without data loss.

### In a parser:

+ For any input, it should output either a successful parse with a valid
  parse tree, or error information.

+ For any valid input (generated by randomly walking the grammar), it
  should output a valid parse tree.

### In a flash memory wear-leveling system:

+ For any sequence of writes (of arbitrary, bounded size), no flash page
  should have significantly more writes than the others.

### In a datagram-based network:

+ For any order of receiving packets (including retransmissions), all
  packets should eventually be received and acknowledged, and every
  packet should be checksummed once, in order.
  
### In data structure implementations:

+ For any sequence of insertions and deletions, a balanced binary tree
  should always stay approximately balanced.
  
+ For any input, a sorting algorithm should produce sorted output.
